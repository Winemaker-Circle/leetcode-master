# 原码 反码 补码
## 机器数和真正值

**1. 机器数**\
&emsp;一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1\
\
&emsp;**比如**: 十进制中的数 +3 ，计算机字长为8位，转换成二进制就是**00000011**。如果是 -3 ，就是 **10000011** 。\
\
**2. 真值**\
&emsp;因为第一位是符号位，所以机器数的**形式值**就不等于**真正**的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

## 原码、补码、反码
**1. 原码**\
&emsp;原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
```
[+1]原 = 0000 0001

[-1]原 = 1000 0001
```
&emsp;第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
```
[1111 1111 , 0111 1111]
即
[-127 , 127]
```
_**原码即是一种很直接的人脑转义方式**_\
\
**2. 反码**\
反码的表示方法是:\
**正数**：反码是其本身\
**负数**:反码是在其原码的基础上, 符号位不变，其余各个位取反.\
```
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
```
**_可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算._**\
\
**3. 补码**\
补码的表示方法是:\
**正数**：正数的补码就是其本身\
**负数**:负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\
```
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```
**_对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值._**

## 为何要用原码，反码，补码
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.
```
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```
&emsp;首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, **即: 1-1 = 1 + (-1) = 0** , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了\
\
**计算十进制的表达式: 1-1=0**

```
# 原码处理
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
# 反码处理
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
```
&emsp;发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.
```
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
```
&emsp;-1-127的结果应该是-128 （_**补码符号位参与运算**_） , 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)\
\
&emsp;使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].\
\
&emsp;因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

## 补充
**同余的概念**
```
4 mod 12 = 4
16 mod 12 = 4
28 mod 12 = 4
```
所以4, 16, 28关于模 12 同余.

**负数取模**
```
# 取模数学运算 LJ 取整数
x mod y = x - y L x / y J

-3 mod 2
= -3 - 2xL -3/2 J
= -3 - 2xL-1.5J
= -3 - 2x(-2)
= -3 + 4 = 1

(-2) mod 12 = 12-2=10
(-4) mod 12 = 12-4 = 8
(-5) mod 12 = 12 - 5 = 7
```
接下来回到二进制的问题上, 看一下: 2-1=1的问题.
```
2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反

先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.

(-1) mod 127 = 126
126 mod 127 = 126

(-1) ≡ 126 (mod 127)
2-1 ≡ 2+126 (mod 127)

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1
所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!
```

**既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?**
```
2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补
# 去掉符号位
[0111 1111]原 = 127

# 其实就是和反码+1取膜
(-1) mod 128 = 127
127 mod 128 = 127
2-1 ≡ 2+127 (mod 128)

此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].
但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]
```


## 位运算
![img.png](img.png)
### 按位与 &
按位与的规则是：参与运算的两个值，如果相应位都为1，则该位的结果为1，否则为0，也就是说：
```
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0
```
python 默认32，暂时就按照8位写，后面位未用到
```
3 & 5 = 1
0000 0011  # 3的补码
0000 0101  # 5的补码
0000 0001  # 根据按位与的规则，得出补码结果

-2 & -3 = -4
1111 1110	# -2的补码
1111 1101	# -3的补码
1111 1100	# 结果
补->原
1111 1100	# 补码
1000 0011	# 符号位不变，数值位按位取反
1000 0100	# 末位加1

>>> -2 & 3 = 2
1111 1110	 # -2的补码
0000 0011	 # 3的补码
0000 0010	 # 结果
```
**小结：在按位与的结果中，只有是负数的情况下，才需要将补码转换为原码，然后再求对应的十进制数。**
### 按位或 |
先把口诀放这里：按位或运算，只要对应两个二进制位有一个为1时，结果就为1。也就是说：
```
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0
```
题目
```
3 | 5 = 7
0000 0011 	# 3的补码
0000 0101	# 5的补码
0000 0111	# 结果

-2 | -3 = -1
1111 1110	 # -2的补码
1111 1101	 # -3的补码
1111 1111	 # 结果
补->原
1111 1111	# 结果
1000 0000	# 高位不变，其余取反
1000 0001	# 末位加1

-2 | 3 = -1
1111 1110	# -2的补码
0000 0011	# 3的补码
1111 1111	# 结果
补->原
1111 1111	# 结果
1000 0000	# 高位不变，其余取反
1000 0001	# 末位加1

```

### 按位异或 ^
```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0

3 ^ 5 = 6
0000 0011 	# 3的补码
0000 0101	# 5的补码
0000 0110	# 结果，注意按照规则来

-2 ^ -3 =3
1111 1110	# -2的补码
1111 1101	# -3的补码
0000 0011	# 结果

 -2 ^ 3 = -3
1111 1110	# -2的补码
0000 0011	# 3的补码
1111 1101	# 结果
补->原
1111 1101	# 结果
1111 1100	# -1
1000 0011	# 取反
```
最高位为负号，二进制的101是3， 所以对应的十进制是-3。
最后，来总结一下异或特点，0异或任何数得这个数（0异或0得0），一个数与自己异或时结果为
```
>>> 0 ^ 0
0
>>> 0 ^ 3
3
>>> 0 ^ -3
-3
>>> 3 ^ 3
0
```
###按位取反 ~
```
 ~ 3 = -4
0000 0011 	# 3的补码
1111 1100	# 结果是负数，还要转为原码
1000 0011	# 高位不变，其余取反
1000 0100	# 末位加一

 ~ -2 = 1
 1111 1110	 # -2的补码
 0000 0001
```
###按位左移 <<
```
2 << 3 = 16
0000 0010	# 2的补码
0001 0000   # *2 3次
```

###按位右移 >>
```
2 >> 3 = 0
0000 0010	# 2的补码
0000 0000
# 移动到第3位时，把1就移没了，剩下全是0最终的十进制结果是0。
```